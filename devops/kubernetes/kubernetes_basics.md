### https://kubernetes.io/docs/tutorials/hello-minikube/

- Install minicube via exe
- minikube start
- kubectl get po -A: lists services
- minikube dashboard: a pretty web interface
- kubectl create deployment hello-minikube --image=k8s.gcr.io/echoserver:1.4
- kubectl expose deployment hello-minikube --type=NodePort --port=8080
- kubectl get services hello-minikube

### https://kubernetes.io/docs/tutorials/kubernetes-basics/

- 1 - Create a Kubernetes Cluster
    - Kubernetes coordinates a highly available cluster of computers that are connected to work as a single unit
    - Two parts to a k8s cluster: the Control Plane and Nodes
        - Nodes can be VMs or physical hosts
        - Each node has a cubelet, an agent for managing the node and communicating with the plane
        - Nodes also have container management software, like containerd or Docker
        - clusters handling production envs should have at least 3 nodes
    - Minicube deploys a simple cluster with one node. Tutorial:
        - minikube start
        - minikube version
        - kubectl version
        - kubectl cluster-info: shows IPs of control plane, DNS
        - kubectl get-nodes: shows status of nodes
- 2 - Use kubectl to Create a Deployment
    - With a running cluster, you can deploy containerized applications on it by creating a Kubernets Deplopyment Configuration
    - Once instances are created, the Kubernetes Deployment Controller monitors the instances for self-healing
    - Pre-orchestration, installation scripts would start apps, but would struggle to recover from machine failure
    - kubectl: CLI wrapper for Kubernetes API
    - Commands tend to be formatted as: kubectl <action> <resource>
    - Deploying an app:
        - kubectl get nodes
        - kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
            - this did a few things: first, searched for a node to run on
            - scheduled the application to run on the node
            - configured the cluster to reschedule the instance on a new node if needed 
        - kubectl get deployments
        - You can access the pod through a proxy
- 3 - Viewing Pods and Nodes
    - A pod stores some containers and some shared resources:
        - Shared storage as volumes
        - Shared networking as a cluster IP address
        - Container image versions or ports to use
    - A pod is effectively a logical host - containers within a pod are tightly coupled
    - Some commands:
        - kubectl get pods
        - kubectl describe pods
        - kubectl logs
        - kubectl exec $POD_NAME -- env
        - kubectl exec -ti $POD_NAME -- bash
            - full shell, talk to the pod's services with localhost
        - exit
- 4 - Using a Service to Expose your App
    - Pods are mortal, and have life cycles
    - When a worker dies, the pods running on the node are lost. 
    - Replica Sets: can aquire and create pods for scaling out
    - Services: define logical sets of pods, and a policy to access them 
        - Enable loose coupling between dependend Pods
        - Route traffic across pods
        - Allow pods to die and replicate in kubernetes without impacting your application
    - Labels
        - a grouping primitive for logical operation on objects
    - More Commands:
        - kubectl get pods: to check we're running
        - kubectl get services
        - kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080
        - kubectl describe services/kubernetes-bootcamp
        - export NODE_PORT <command>
        - curl $(minicube ip):$NODE_PORT 
        - kubectl describe deployment
        - kubectl get pods -l app=kubernetes-bootcamp
            - logical operators on labels
        - kubectl get deployments -l app=kubernetes-bootcamp
        - export POD_NAME <command>
        - kubectl label pods $POD_NAME version=v1
        - kubectl describe pods $POD_NAME
        - kubectl delete service -l app=kubernetes-bootcamp
        - kubectl get services
        - curl $(minikube ip):$NODE_PORT
            - fails to connect, hence service is deleted
        - kubectl exec -ti $POD_NAME --curl localhost:8080
            - this works, because we're no longer reaching from the outside via the service
- 5 - Running Multiple Instances of your App
    - So far, we've created a **Deployment**, and exposed it via a **Service**
    - The Deployment created only one pod. Scaling happens via **changing the number of replicas in a deployment.**
    - K8s supports Autoscaling pods
    - Commands:
        - kubectl get rs
            - gets replicas
        - kubernetes scale deployment/kubernetes-bootcamp replicas=4
            - damn, that's pretty easy
        - kubectl get deployments: now shows 4/4 under ready
        - kubectl get pods -o wide
            - shows 4 pods with different IPs
        - kubectl describe deployments/kubernetes-bootcamp
        - export NODE_PORT
            - define the service node port as NODE_PORT
        - curl $(minikube ip):$NODE_PORT
            - hits a different node each time - loads balanced, baby
        - kubectl scale deployments/kubernetes-bootcamp --replicas=2
- 6 - Performing a Rolling Upgrade
    - Rolling updates allow the following things: 
        - Promote an application from one env to another via container image updates
        - rollback to prior versions
        - CICD of applications with zero downtime
    - Commands
        Kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2
